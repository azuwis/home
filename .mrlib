# -*- mode: shell-script -*-

lib =
    no_cmd() {
        ! which "$1" >/dev/null 2>&1
    }
    workstation() {
        test -e /etc/fonts/local.conf
    }
    download() {
        # download <url> <file> <mode>
        set -eu
        local url="$1"
        local file="${2:--}"
        if [ x"$file" = x"-" ]; then
            file="$(basename "$url")"
        fi
        file="${MR_REPO}/${file}"
        local mode="${3:--}"
        local now="$(date +%s)"
        local mtime=0
        local cache_dir="${HOME}/.mrcache/"
        mkdir -p "$cache_dir"
        local cache_path="$(readlink -f "$file")"
        cache_path="$(echo "$cache_path" | sed 's/\//::/g')"
        cache_path="${cache_dir}/${cache_path}"
        local header_file="${cache_path}.header"
        local newer_file="${cache_path}.newer"
        local update_timestamp=0
        local etag="-"
        if [ -e "$file" ]; then
           mtime="$(stat -c %Y "$file")"
           # skip if file newer than 7 days
           if [ "$((now - mtime))" -lt 604800 ]; then
               return
           fi
        fi
        echo -n "$file| updating: "
        if [ -e "$header_file" -a -e "$file" ]; then
            etag="$(awk '/^[Ee][Tt][Aa][Gg]:/ {print $2}' "$header_file" | head -n 1 | tr -d '\r')"
        fi
        if [ ! -e "$file" ]; then
            curl --silent --fail --show-error --location \
                 --dump-header "$header_file" \
                 --output "$file" "$url"
            test "$?" -eq 0 && update_timestamp=1
        elif [ x"$etag" != x"-" ]; then
            # use etag
            curl --header "If-None-Match: $etag" \
                 --silent --fail --show-error --location \
                 --dump-header "$header_file" \
                 --output "$newer_file" "$url"
            test "$?" -eq 0 && update_timestamp=1
            # if not empty
            if [ -s "$newer_file" ]; then
                mv "$newer_file" "$file"
            fi
        else
            # use last modified
            curl --time-cond "$file" \
                 --silent --fail --show-error --location \
                 --dump-header "$header_file" \
                 --output "$file" "$url"
            test "$?" -eq 0 && update_timestamp=1
        fi
        if [ "$mtime" -ne "$(stat -c %Y "$file")" ]; then
            echo -n "updated"
            if [ x"$mode" != x"-" ]; then
                echo -n ", mode: $mode"
                chmod "$mode" "$file"
            fi
        else
            echo -n "unchanged"
        fi
        echo
        # update file timestamp if curl success
        if [ "$update_timestamp" -eq 1 ]; then
            touch "$file"
        fi
    }
    github_token() {
        GITHUB_OAUTH="${HOME}/.github_oauth"
        GITHUB_TOKEN=`cat "$GITHUB_OAUTH"` || true
        if ! echo -n "$GITHUB_TOKEN" | grep -qE '^[0-9a-f]{40}$'; then
            GITHUB_TOKEN="`curl -s -u "$GITHUB_USER" -d '{"scopes":["repo"],"note":"for mr"}' https://api.github.com/authorizations | awk -F'"' '/token/ {print $4}'`"
            echo "$GITHUB_TOKEN" > "$GITHUB_OAUTH"
            chmod 600 "$GITHUB_OAUTH"
        fi
        echo "$GITHUB_TOKEN"
    }

# Mark as deleted
delete = mr -c "$MR_CONFIG" config "`pwd`" deleted="true"

# Create repo at github
create =
    GITHUB_REPO="$1"
    GITHUB_DESC="$2"
    ssh_url="`curl -s -H "Authorization: token $(github_token)" https://api.github.com/user/repos -d '{"name":"'"$GITHUB_REPO"'", "description":"'"$GITHUB_DESC"'"}' | awk -F'"' '/git_url/ {print $4}'`"
    if [ -z "$ssh_url" ]; then
        error "cannot create repo at github.com"
    else
        url="`LC_ALL=C git config --get remote.origin.url`" || true
        if [ -d ".git" -a -z "$url" ]; then
            git remote add origin $ssh_url
        fi
    fi

# Create repo at github when origin remote is empty
git_register =
    url="`LC_ALL=C git config --get remote.origin.url`" || true
    if [ -z "$url" ]; then
        case "$PWD" in
            ${HOME}/.*)
                GITHUB_REPO=`echo ${PWD#$HOME/} | sed -e 's/\//_/g'`;;
            ${HOME}/debian/*)
                GITHUB_REPO="deb_${MR_REPO}";;
            *)
                GITHUB_REPO="${MR_REPO}";;
        esac
        if [ -n "$REPO" ]; then
            GITHUB_REPO="${REPO}"
        fi
        echo "git origin url not found, creating $GITHUB_REPO at github.com"
        read -p "repo description: " GITHUB_DESC
        ssh_url="`curl -s -H "Authorization: token $(github_token)" https://api.github.com/user/repos -d '{"name":"'"$GITHUB_REPO"'", "description":"'"$GITHUB_DESC"'"}' | awk -F'"' '/git_url/ {print $4}'`"
        if [ -z "$ssh_url" ]; then
            error "cannot create repo at github.com"
        else
            git remote add origin $ssh_url
            url=$ssh_url
        fi
    fi
    echo "Registering git url: $url in $MR_CONFIG"
    mr -c "$MR_CONFIG" config "`pwd`" checkout="git clone '$url' '$MR_REPO'"

# Push only when having unpushed commit
git_push =
    if [ $(git --no-pager log --branches --not --remotes --simplify-by-decoration --oneline | wc -l) -gt 0 ]; then
        git push "$@"
    fi

# Fork at github, set origin remote to the fork, and upstream remote to the upstream
git_fork =
    UPST=`git config --get remote.origin.url`
    if ! echo $UPST | grep -F "$GITHUB_USER" >/dev/null 2>&1; then
        ORIG=`echo $UPST | sed -e 's/\(.*github\.com\/\)[^/]\+\(\/.*\)/\1'"$GITHUB_USER"'\2/'`
        echo "forking $UPST ..."
        curl -s -X POST -H "Authorization: token $(github_token)" `echo $UPST | sed -e 's/git:\/\/github\.com/https:\/\/api\.github.com\/repos/' -e 's/\.git$/\/forks/'` | awk -F'"' '/git_url/ {print $4}' | head -n1
        git remote set-url origin $ORIG
        git remote add upstream $UPST
        BASE_REPO=`basename $MR_REPO`
        mr -c "$MR_CONFIG" config "`pwd`" checkout="git clone '$ORIG' '$BASE_REPO'"
        mr -c "$MR_CONFIG" config "`pwd`" post_checkout="cd '$BASE_REPO' && git remote add upstream '$UPST'"
    fi

# Fetch and merge current branch if upstream remote exist
git_update =
    git pull "$@"
    url=`git config --get remote.upstream.url` || true
    if [ x"$url" != x ]; then
        git fetch upstream
        git merge upstream/`git rev-parse --abbrev-ref HEAD`
    fi

git_gc = git gc "$@"
